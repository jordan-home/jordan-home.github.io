---
title: 类和原型
date: 2021-4-22
sidebar: auto
categories:
  - IT
tags:
  - 读书笔记
  - JS
---

::: tip 书籍简介

书名：《你不知掉的JavaScript（上卷）》～`混合对象类`，`原型`和`行为委托`

作者：[美] Kyle Simpson

分类：IT

:::

<!-- more -->

## 混合对象-类

类是一种设计模式，JS中也有类似的语法，但是JS中的类和其他语言中的类完全不同。

类意味着复制。

传统类的实例化意味着类的行为会复制到实例中，子类会复制父类的行为。多态也只是引用父类的方法，加以复写。

JS中不会像类那样自动创建对象的副本。

## 原型

### `Prototype` ：内置属性：原型

#### Object.prototype

原型机制就是指对象中的一个内部链接引用另一个对象。

所有普通的原型链最终会指向内置的Object.prototype。这个Object.prototype对象拥有许多JS中通用的功能，包括 `.toString()`,`.valueOf()`,`.hasOwnProperty(..)`,`.isPrototypeOf(..)`等。

#### 属性设置和屏蔽

```js
obj.a = 'mm'
```

首先，会检查obj是否包含a属性，有的话赋值；没有的话，则向上查找原型链。如果在原型链找到了，且是只读的，则赋值失败；若可写的，则直接在obj上添加属性a并赋值，成为屏蔽属性；若找到的是一个S etter,则直接调用这个setter。

当然，如果你只想设置屏蔽属性，也就是直接在对象上定义一个属性，则

```js
Object.defineProperty(obj, 'a', {...})
```

### 类

JS中只有对象，少有的不通过类创建对象的语言。

#### ‘类’函数

JS中存在一个行为：模仿类。模仿类的原理是基于原型的存在。

在JS中没有复制（或者说实例化）的机制，而是创建多个对象，它们的prototype关联的是同一个对象。

```js
function Foo() { ... }
var a = new Foo()
Object.getPrototypeOf( a ) === Foo.prototype; // true
```

需要注意是，`new Foo()` 这个函数调用实际上并没有**直接** 创建关联，这个关联只是一个意外的副作用。**更直接** 的方法是`Object.create(..)`

#### 构造函数

`Foo`并不是一个构造函数，和其他的函数没啥区别，只是看起来是new 调用它构造了一个对象。在JavaScript中对于“构造函数”最准确的解释是，所有带`new` 的函数调用。

```js
function Foo() { /* .. */ }

Foo.prototype = { /* .. */ }; // 创建一个新原型对象

var a1 = new Foo();
a1.constructor === Foo; // false!
a1.constructor === Object; // true!
```

解释：

`a1` 并没有`.constructor` 属性，所以它会委托`[[Prototype]]` 链上的`Foo.prototype` 。但是这个对象也没有`.constructor` 属性（不过默认的`Foo.prototype` 对象有这个属性！），所以它会继续委托，这次会委托给委托链顶端的`Object.prototype` 。**这个** 对象有`.constructor` 属性，指向内置的`Object(..)` 函数。

### (原型)继承

检查一个实例（JavaScript中的对象）的继承祖先（JavaScript中的委托关联）通常被称为**内省** （或者**反射** ）。

instanceof: a 的原型链上可否找到指向 A.prototype的对象

X.isPrototypeOf(Y) : X是否出现在Y的原型链中

```js
a instanceof A

A.prototype.isPrototypeOf( a ); // true
```

### 对象关联

如果在第一个对象上没有找到需要的属性或者方法引用，引擎就会继续在`[[Prototype]]` 关联的对象上进行查找。同理，如果在后者中也没有找到需要的引用就会继续查找它的`[[Prototype]]` ，以此类推。这一系列对象的链接被称为“原型链”。简单的说，原型的机制本质上是对象之间的关联关系

#### 创建关联

`Object.create(..)` 会创建一个新对象（`bar` ）并把它关联到我们指定的对象（`foo` ），这样我们就可以充分发挥`[[Prototype]]` 机制的威力（委托）并且避免不必要的麻烦（比如使用`new` 的构造函数调用会生成`.prototype` 和`.constructor` 引用）。

不**需要** 类来创建两个对象之间的关系，只需要通过委托来关联对象就足够了。而`Object.create(..)` 不包含任何“类的诡计”，所以它可以完美地创建我们想要的关联关系。

#### 关联关系是否备用

当对象A上找不到属性b,就会在A的原型链上找到来代替，这里体现了关联关系的备用；但是，这并不应该成为使用关联关系的目的。

上面这种看作直接委托的模式，会导致api不够清晰，更推荐使用内部委托的模式。

```js
var preObj = { cool: function(){ ... } }
var obj = Object.create(preObj)
obj.doCool = function() { this.cool() ... }

obj,doCool()
```

## 行为委托

### 委托

**委托行为** 意味着某些对象在找不到属性或者方法引用时会把这个请求委托给另一个对象。API接口的设计中，委托最好在内部实现，不要直接暴露出去。

🈲️：互相委托

### 类和对象

ES6中 的class是一种语法糖，本质上依然是函数。JS中仍然不存在真正的类。

对象关联可以**更好地支持关注分离（separation of concerns）原则** ，创建和初始化并不需要合并为一个步骤。

### 更简洁的设计

### 更好的语法

### 内省

检查实例的类型叫做内省。

* instanceof

* 鸭子模式：如果看起来像鸭子，叫起来像鸭子，那就一定是鸭子

  例子：

  出于各种各样的原因，我们需要判断一个对象引用是否是 Promise，但是判断的方法是检查对象是否有 then() 方法。换句话说，如果对象有 then() 方法，ES6的 Promise 就会认为这个对象是“可持续”（ thenable）的，因此会期望它具有 Promise 的所有标准行为。

* Foo.isPrototypeOf( Bar )