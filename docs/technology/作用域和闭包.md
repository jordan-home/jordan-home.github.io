---
title: 作用域和闭包
date: 2021-4-20
sidebar: auto
categories:
  - IT
tags:
  - 读书笔记
  - JS
sticky: 1
---

::: tip 书籍简介

书名：《你不知掉的JavaScript（上卷）》～作用域和闭包

作者：[美] Kyle Simpson

分类：IT

:::

<!-- more -->

## 作用域是什么

​首先，我们需要了解一下作用域的定义：`一套设计良好的规则来存储变量，并且之后可以方便地找到这些变量。这套规则被称为作用域`。

### 编译原理

​程序语言通常可以分为编译型和解释型。一般将JS视为动态或解释执行的语言，但实际上它属于编译型，不过和一般的编译型语言有明显的差异。差异主要在于，一般的编译型语言会提前编译，然后编译结果可以在分布式系统上进行移植，然而JS不是这样，它是执行前编译。
​虽然如此，我们还是可以依据传统，将它的编译分为三个步骤：词法分析、语法分析和生成执行代码。在词法分析阶段，会将代码分解成有意义的代码块；在语法分析阶段，会对代码块进行组织，形成AST(抽象语法树)；最后生成可执行代码。后两个阶段，会对性能进行优化。

### 理解作用域

编译并运行JS过程中，有三个角色参与：引擎、编译器和作用域。其中，引擎全程参与编译和执行；编译器参与编译；作用域则是一套规则，确定变量访问的权限。

​需要了解的两个术语：RHS和LHS,它们是引擎查询变量的两个方式:

* RHS:与简单地查找某个变量的值别无二致

* LHS 查询则是试图找到变量的容器本身，从而可以对其赋值

### 作用域嵌套

遍历嵌套作用域链的规则很简单：引擎从当前的执行作用域开始查找变量，如果找不到，就向上一级继续查找。当抵达最外层的全局作用域时，无论找到还是没找到，查找过程都会停止。

### 异常

* ReferenceError：同作用域判别失败相关
* TypeError：作用域判别成功了，但是对结果的操作非法或不合理

## 词法作用域

​作用域一般分为两种，分别是词法作用域和动态作用域。

​词法作用域，简单的说，词法作用域就是定义在词法阶段的作用域。是由你在写代码时将变量和块作用域写在哪里来决定的，词法分析器在处理时保持不变。

### 欺骗词法作用域的方法

​运行时来“修改”（也可以说欺骗）词法作用域,也就是欺骗词法作用域会导致性能下降.

#### eval

​！在程序中动态生成代码的使用场景非常罕见，因为它所带来的好处无法抵消性能上的损失。

```js
function foo(str, a) {
    eval( str ); // 欺骗！
    console.log( a, b );
}
var b = 2;
foo( "var b = 3;", 1 );
```

和`eval`类似的一些类似功能：

* `setTimeout(..)` 和`setInterval(..)` 的第一个参数**可以** 是字符串，字符串的内容可以被解释为一段动态生成的函数代码。⚠️避免使用
* `new Function(..)` 函数的行为也很类似，**最后** 一个参数可以接受代码字符串，并将其转化为动态生成的函数（前面的参数是这个新生成的函数的形参）。也不推荐使用

#### with（🙅不要用）

```js
var obj = {
    a: 1,
    b: 2,
};

// 单调乏味的重复"obj"
obj.a = 2;
obj.b = 3;

// 简单的快捷方式
with (obj) {
    a = 3;
    b = 4;
}
```

​`with` 通常被当作重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。`with` 可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域，因此这个对象的属性也会被处理为定义在这个作用域中的词法标识符。

## 函数作用域和块作用域

​函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用。

### 隐藏内部实现

​对函数的传统认知就是先声明一个函数，然后再向里面添加代码。也可以反过来理解，从所写的代码中挑选出一个任意的片段，然后用函数声明对它进行包装，也就是隐藏内部实现。为什么“隐藏”变量和函数是一个有用的技术？有很多原因促成了这种基于作用域的隐藏方法。它们大都是从最小特权原则中引申出来的，也叫`最小授权或最小暴露原则`[指在软件设计中，应该最小限度地暴露必要内容，而将其他内容都“隐藏”起来，比如某个模块或对象的 API 设计]。

​隐藏的另外一个优点，就是规避冲突。

### 函数作用域

利用函数隐藏了内部，但是同时也会产生一个具名函数，函数名也会污染外部作用域；且需要手动执行这个函数。鉴于此，我们可以使用立即执行函数表达式（IIFE）。

```js
(function name(x){...})(x)
(function name(x){...}(x))
```

函数表达式不同于函数声明，区别的方式：`function` 是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。

函数表达式常见的用法，包括

```js
setTimeOut(function (){...}, 1000)
```

上面这个是匿名函数表达式。

匿名的函数写起来快捷，但是缺点明显：可读性差，在栈追踪时困难。所以，推荐具名函数。

### 块作用域

* `with`从对象中创建出的作用域仅在`with` 声明中而非外部作用域中有效

* `try` /`catch` 的`catch` 分句会创建一个块作用域，其中声明的变量仅在`catch` 内部有效

```js
try {
    undefined(); // 执行一个非法操作来强制制造一个异常
} catch (err) {
    console.log( err ); // 能够正常执行！
}
console.log( err ); // ReferenceError: err not found
```

* `let `关键字可以将变量绑定到所在的任意作用域中（通常是 { .. }内部）。换句话说，` let `为其声明的变量隐式地了所在的块作用域

* `const` ，同样可以用来创建块作用域变量

## 提升

包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理。也就是，先有声明，然后赋值。

```js
console.log(a)
var a = 2; 
foo()
function foo(){...}
// 等价于
function foo() {...}
var a;
console.log(a)
a = 2;
foo()
```

声明本身会被提升，而包括函数表达式的赋值在内的赋值操作并**不会** 提升。

## 闭包

JavaScript中闭包无处不在，你只需要能够识别并拥抱它。闭包是基于词法作用域书写代码时所产生的自然结果，你甚至不需要为了利用它们而有意识地创建闭包。

### 定义

当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。

```js
function foo() {
    var a = 2;
    function bar() { 
        console.log( a );
    }
    return bar;
}
var baz = foo();

baz(); // 2 ———— 朋友，这就是闭包的效果。
```

无论通过何种手段将内部函数**传递** 到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。

本质上**无论何时何地** ，如果将函数（访问它们各自的词法作用域）当作第一级的值类型并到处传递，你就会看到闭包在这些函数中的应用。在定时器、事件监听器、Ajax请求、跨窗口通信、Web Workers或者任何其他的异步（或者同步）任务中，只要使用了**回调函数** ，实际上就是在使用闭包！

经典例子：

```js
for (var i=1; i<=5; i++) {
    setTimeout( function timer() {
        console.log( i );
    }, i*1000 );
}
```

```js
for (var i=1; i<=5; i++){
    (function() {
    		setTimeout( function timer() {console.log( i );}, i*1000 );
    })()
 }
```

```js
for (var i=1; i<=5; i++) {
    (function() {
        var j = i;
        setTimeout( function timer() { console.log( j ) }, j*1000 );
    })();
}
```

```js
for (var i=1; i<=5; i++) {
    (function(j) {
        setTimeout( function timer() {console.log( j )}, j*1000 );
    })( i );
}
```

```js
for (var i=1; i<=5; i++) {
    let j = i; // 是的，闭包的块作用域！
    setTimeout( function timer() { console.log( j ) }, j*1000 );
}
```

```js
for (let i=1; i<=5; i++) {
    setTimeout( function timer() {console.log( i )}, i*1000 );
}
```

块作用域和闭包联手

### 模块

一种代码模式：利用了闭包的原理

看代码

```js
function CoolModule() {
    var something = "cool"; 
    function doSomething() { 
        console.log( something );
    }
    return {
        doSomething: doSomething, 
    };
}
var foo = CoolModule(); 

foo.doSomething(); // cool
```

模块模式需要具备两个必要条件:

1. 必须有外部的封闭函数，该函数必须至少被调用一次（每次调用都会创建一个新的模块实例）
2. 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态

上面的方法可以被调用多次，产生多个模块实例。如果想应用单例模式，可以：

```js
var foo = (function CoolModule() {...}())
foo.doSomething()
```

